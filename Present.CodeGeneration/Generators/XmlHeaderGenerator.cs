// Copyright (c) Present.NET. All Rights Reserved.
// Present.NET is licensed under the MIT License. For usage and redistribution terms please refer to the LICENSE file.
// For more information about the Present.NET project visit https://github.com/ImAMightyPirate/Present.

namespace Present.CodeGeneration.Generators
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using EnsureThat;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Present.CodeGeneration.Constants;
    using Present.CodeGeneration.Contracts;
    using Present.CodeGeneration.Wrappers.Custom;

    /// <summary>
    /// Responsible for generating the Roslyn definition for an XML header.
    /// </summary>
    public class XmlHeaderGenerator : IXmlHeaderGenerator
    {
        private readonly IAssemblyWrapper assemblyWrapper;

        /// <summary>
        /// Initializes a new instance of the <see cref="XmlHeaderGenerator"/> class.
        /// </summary>
        /// <param name="assemblyWrapper">The assembly wrapper.</param>
        public XmlHeaderGenerator(IAssemblyWrapper assemblyWrapper)
        {
            this.assemblyWrapper = assemblyWrapper;
        }

        /// <summary>
        /// Generates a Roslyn comment trivia for the XML copyright header.
        /// </summary>
        /// <param name="assemblyQualifiedName">The assembly qualified name of the type being wrapped.</param>
        /// <returns>The generated XML copyright header.</returns>
        public DocumentationCommentTriviaSyntax Generate(string assemblyQualifiedName)
        {
            Ensure.That(assemblyQualifiedName).IsNotNullOrWhiteSpace();

            var documentationCommentTrivia = SyntaxFactory.DocumentationCommentTrivia(
                SyntaxKind.SingleLineDocumentationCommentTrivia,
                SyntaxFactory.List(
                    new XmlNodeSyntax[]
                    {
                        SyntaxFactory.XmlText().WithTextTokens(SyntaxFactory.TokenList(this.GetDocumentationCommentToken(string.Empty, false))),
                        this.GetDocumentationXmlElement(assemblyQualifiedName),
                        SyntaxFactory.XmlText().WithTextTokens(SyntaxFactory.TokenList(this.GetNewLineToken())),
                        SyntaxFactory.XmlText().WithTextTokens(SyntaxFactory.TokenList(this.GetNewLineToken()))
                    }));

            return documentationCommentTrivia;
        }

        private XmlElementSyntax GetDocumentationXmlElement(string assemblyQualifiedName)
        {
            var targetFrameworkAttribute = this.assemblyWrapper
                .GetEntryAssemblyTargetFrameworkAttributes()
                .FirstOrDefault();

            var tokenList = new List<SyntaxToken>();
            tokenList.AddRange(this.GetDocumentationCommentToken(Resource.AutoGenerationDisclaimer));
            tokenList.AddRange(this.GetDocumentationCommentToken(Resource.ProjectWebsite));
            tokenList.AddRange(this.GetDocumentationCommentToken(Resource.LicenceDeclaration));
            tokenList.AddRange(this.GetDocumentationCommentToken($"{Resource.Type}: {assemblyQualifiedName}"));
            tokenList.AddRange(this.GetDocumentationCommentToken($"{Resource.Framework}: {targetFrameworkAttribute.FrameworkName}"));
            tokenList.AddRange(this.GetDocumentationCommentToken(string.Empty));

            return SyntaxFactory.XmlExampleElement(
                    SyntaxFactory.SingletonList<XmlNodeSyntax>(
                        SyntaxFactory.XmlText().WithTextTokens(
                            SyntaxFactory.TokenList(tokenList))))
                .WithStartTag(SyntaxFactory.XmlElementStartTag(SyntaxFactory.XmlName(SyntaxFactory.Identifier(XmlElementIdentifier.AutoGenerated))))
                .WithEndTag(SyntaxFactory.XmlElementEndTag(SyntaxFactory.XmlName(SyntaxFactory.Identifier(XmlElementIdentifier.AutoGenerated))));
        }

        private SyntaxToken GetNewLineToken()
        {
            return SyntaxFactory.XmlTextNewLine(
                SyntaxFactory.TriviaList(),
                Environment.NewLine,
                Environment.NewLine,
                SyntaxFactory.TriviaList());
        }

        private IList<SyntaxToken> GetDocumentationCommentToken(string commentText, bool prefixNewLine = true)
        {
            var syntaxTokens = new List<SyntaxToken>();

            if (prefixNewLine)
            {
                syntaxTokens.Add(this.GetNewLineToken());
            }

            syntaxTokens.Add(SyntaxFactory.XmlTextLiteral(
                SyntaxFactory.TriviaList(SyntaxFactory.DocumentationCommentExterior(Comment.SingleLinePrefix)),
                $" {commentText}",
                $" {commentText}",
                SyntaxFactory.TriviaList()));

            return syntaxTokens;
        }
    }
}
